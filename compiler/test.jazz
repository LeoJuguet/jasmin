// require "params.jinc"
// require "reduce.jinc"
// require "fips202.jinc"
// require "zetas.jinc"



// params.jinc
param int MLKEM_Q = 3329;
param int MLKEM_N = 256;
param int MLKEM_K = 3;
param int MLKEM_VECN =  MLKEM_K * MLKEM_N;

param int MLKEM_SYMBYTES = 32;
param int MLKEM_ETA = 2;
param int MLKEM_POLYBYTES = 384;
param int MLKEM_POLYVECBYTES = (MLKEM_K * MLKEM_POLYBYTES);
param int MLKEM_POLYCOMPRESSEDBYTES = 128;
param int MLKEM_POLYVECCOMPRESSEDBYTES = (MLKEM_K * 320);
param int MLKEM_MSGBYTES = MLKEM_SYMBYTES;
param int MLKEM_CT_LEN = MLKEM_POLYVECCOMPRESSEDBYTES + MLKEM_POLYCOMPRESSEDBYTES;
param int MLKEM_INDCPA_PUBLICKEYBYTES = MLKEM_POLYVECBYTES + MLKEM_SYMBYTES;
param int MLKEM_PUBLICKEYBYTES = MLKEM_INDCPA_PUBLICKEYBYTES;
param int MLKEM_SSBYTES = 32;


fn _poly_frommsg(reg ptr u16[MLKEM_N] rp, reg u64 ap) -> stack u16[MLKEM_N]
{
  reg u8 c;
  reg u16 t;
  inline int i;

  for i = 0 to 32
  {
    c = (u8)[ap + i];

    t = (16u)c; 
    t &= 1;
    t *= (MLKEM_Q+1)/2;
    rp[8*i] = t;
    c >>= 1;

    t = (16u)c; 
    t &= 1;
    t *= (MLKEM_Q+1)/2;
    rp[8*i+1] = t;
    c >>= 1;

    t = (16u)c; 
    t &= 1;
    t *= (MLKEM_Q+1)/2;
    rp[8*i+2] = t;
    c >>= 1;

    t = (16u)c; 
    t &= 1;
    t *= (MLKEM_Q+1)/2;
    rp[8*i+3] = t;
    c >>= 1;

    t = (16u)c; 
    t &= 1;
    t *= (MLKEM_Q+1)/2;
    rp[8*i+4] = t;
    c >>= 1;

    t = (16u)c; 
    t &= 1;
    t *= (MLKEM_Q+1)/2;
    rp[8*i+5] = t;
    c >>= 1;

    t = (16u)c; 
    t &= 1;
    t *= (MLKEM_Q+1)/2;
    rp[8*i+6] = t;
    c >>= 1;

    t = (16u)c; 
    t &= 1;
    t *= (MLKEM_Q+1)/2;
    rp[8*i+7] = t;
    c >>= 1;
  }
  return rp;
}


fn _i_poly_frommsg(reg ptr u16[MLKEM_N] rp, reg ptr u8[32] ap) -> stack u16[MLKEM_N]
{
  reg u8 c;
  reg u16 t;
  inline int i;

  for i = 0 to 32
  {
    c = ap[i];

    t = (16u)c; 
    t &= 1;
    t *= (MLKEM_Q+1)/2;
    rp[8*i] = t;
    c >>= 1;

    t = (16u)c; 
    t &= 1;
    t *= (MLKEM_Q+1)/2;
    rp[8*i+1] = t;
    c >>= 1;

    t = (16u)c; 
    t &= 1;
    t *= (MLKEM_Q+1)/2;
    rp[8*i+2] = t;
    c >>= 1;

    t = (16u)c; 
    t &= 1;
    t *= (MLKEM_Q+1)/2;
    rp[8*i+3] = t;
    c >>= 1;

    t = (16u)c; 
    t &= 1;
    t *= (MLKEM_Q+1)/2;
    rp[8*i+4] = t;
    c >>= 1;

    t = (16u)c; 
    t &= 1;
    t *= (MLKEM_Q+1)/2;
    rp[8*i+5] = t;
    c >>= 1;

    t = (16u)c; 
    t &= 1;
    t *= (MLKEM_Q+1)/2;
    rp[8*i+6] = t;
    c >>= 1;

    t = (16u)c; 
    t &= 1;
    t *= (MLKEM_Q+1)/2;
    rp[8*i+7] = t;
    c >>= 1;
  }
  return rp;
}




fn _poly_sub(reg ptr u16[MLKEM_N] rp ap bp) -> reg ptr u16[MLKEM_N]
{
  reg u16 a;
  reg u16 b;
  reg u16 r;
  reg u64 i;

  i = 0;
  while (i < MLKEM_N) {
    a = ap[(int)i];
    b = bp[(int)i];
    r = a - b;
    rp[(int)i] = r;
    i += 1;
  }
  return rp;
}

