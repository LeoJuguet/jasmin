/* safety annotations */

// abstract predicate bool init_array(int,int,int); /* #parameter, offset, len */
// abstract predicate bool init_scalar(int); /* #parameter, offset, len */
// abstract predicate bool init_memory(u64,int,int); /* ptr, offset, len */
// abstract predicate bool valid_memory(u64,int,int); /* ptr, offset, len */
// abstract predicate bool assigns_array(int,int,int); /* #result, offset, len */
// abstract predicate bool assigns_scalar(int); /* #result */
// abstract predicate bool assigns_memory(u64,int,int); /* ptr, offset, len */

/* require "params.jinc" */

param int KYBER_Q = 3329;
param int KYBER_N = 256;
param int KYBER_K = 3;
param int KYBER_VECN =  KYBER_K * KYBER_N;

param int KYBER_SYMBYTES = 32;
param int KYBER_ETA = 2;
param int KYBER_POLYBYTES = 384;
param int KYBER_POLYVECBYTES = (KYBER_K * KYBER_POLYBYTES);
param int KYBER_POLYCOMPRESSEDBYTES = 128;
param int KYBER_POLYVECCOMPRESSEDBYTES = (KYBER_K * 320);
param int KYBER_MSGBYTES = KYBER_SYMBYTES;
param int KYBER_CT_LEN = KYBER_POLYVECCOMPRESSEDBYTES + KYBER_POLYCOMPRESSEDBYTES;
param int KYBER_INDCPA_PUBLICKEYBYTES = KYBER_POLYVECBYTES + KYBER_SYMBYTES;
param int KYBER_PUBLICKEYBYTES = KYBER_INDCPA_PUBLICKEYBYTES;
param int KYBER_SSBYTES = 32;

/* require "reduce.jinc" */

param int QINV    = 62209;     /* q^(-1) mod 2^16 */
param int MONT    = 2285;      /* 2^16 % Q */
param int BARR    = 20159;     /* (1U << 26)/KYBER_Q + 1 */


inline fn __fqmul(reg u16 a b) -> reg u16
// requires {init_scalar(0) && init_scalar(1)}
// ensures {init_scalar(0)}
{
  reg u32 ad bd c t u;
  reg u16 r;

  ad = (32s) a;
  bd = (32s) b;
  c = ad * bd;

  u = c * (QINV << 16); // merge multiplication of u (<<16)
  u >>s= 16;

  t = u * -KYBER_Q; // replace sub by add
  t += c;
  t >>s= 16;
  r = t;

  return r;
}

inline
fn __barrett_reduce(reg u16 a) -> reg u16
// requires {init_scalar(0)}
// ensures {assigns_scalar(0)}
{
  reg u32 t;
  reg u16 r;
  t = (32s)a;
  t = t * BARR;
  //t = #SAR_32(t, 26);
  t >>s= 26;
  t *= KYBER_Q;
  r = t;
  r = a;
  r -= t;
  return r;
}

/* require "zetas.jinc" */

u16[128] jzetas = {2285, 2571, 2970, 1812, 1493, 1422, 287, 202, 3158, 622, 1577, 182, 962, 2127, 1855, 1468, 
                  573, 2004, 264, 383, 2500, 1458, 1727, 3199, 2648, 1017, 732, 608, 1787, 411, 3124, 1758, 
                  1223, 652, 2777, 1015, 2036, 1491, 3047, 1785, 516, 3321, 3009, 2663, 1711, 2167, 126, 1469, 
                  2476, 3239, 3058, 830, 107, 1908, 3082, 2378, 2931, 961, 1821, 2604, 448, 2264, 677, 2054, 
                  2226, 430, 555, 843, 2078, 871, 1550, 105, 422, 587, 177, 3094, 3038, 2869, 1574, 1653, 
                  3083, 778, 1159, 3182, 2552, 1483, 2727, 1119, 1739, 644, 2457, 349, 418, 329, 3173, 3254, 
                  817, 1097, 603, 610, 1322, 2044, 1864, 384, 2114, 3193, 1218, 1994, 2455, 220, 2142, 1670, 
                  2144, 1799, 2051, 794, 1819, 2475, 2459, 478, 3221, 3021, 996, 991, 958, 1869, 1522, 1628};


u16[128] jzetas_inv = {1701, 1807, 1460, 2371, 2338, 2333, 308, 108, 2851, 870, 854, 1510, 2535, 1278, 1530, 1185, 
                       1659, 1187, 3109, 874, 1335, 2111, 136, 1215, 2945, 1465, 1285, 2007, 2719, 2726, 2232, 2512, 
                       75, 156, 3000, 2911, 2980, 872, 2685, 1590, 2210, 602, 1846, 777, 147, 2170, 2551, 246, 
                       1676, 1755, 460, 291, 235, 3152, 2742, 2907, 3224, 1779, 2458, 1251, 2486, 2774, 2899, 1103, 
                       1275, 2652, 1065, 2881, 725, 1508, 2368, 398, 951, 247, 1421, 3222, 2499, 271, 90, 853, 
                       1860, 3203, 1162, 1618, 666, 320, 8, 2813, 1544, 282, 1838, 1293, 2314, 552, 2677, 2106, 
                       1571, 205, 2918, 1542, 2721, 2597, 2312, 681, 130, 1602, 1871, 829, 2946, 3065, 1325, 2756, 
                       1861, 1474, 1202, 2367, 3147, 1752, 2707, 171, 3127, 3042, 1907, 1836, 1517, 359, 758, 1441};

fn _poly_add2(reg ptr u16[KYBER_N] rp bp) -> stack u16[KYBER_N]
// requires {init_array(0,0,KYBER_N) && init_array(1,0,KYBER_N)}
// ensures {assigns_array(0,0,KYBER_N)}
{
  reg u16 a;
  reg u16 b;
  reg u16 r;
  reg u64 i;

  i = 0;

  while (i < KYBER_N) {
    a = rp[(int)i];
    b = bp[(int)i];
    r = a + b;
    rp[(int)i] = r;
    i += 1;
  }
  return rp;
}

fn _poly_csubq(reg ptr u16[KYBER_N] rp) -> reg ptr u16[KYBER_N]
// requires {init_array(0,0,KYBER_N)}
// ensures {assigns_array(0,0,KYBER_N)}
{
  reg u64 i;
  reg u16 t;
  reg u16 b;

  i = 0;
  while (i < KYBER_N)
  {
    t = rp[(int)i];
    t -= KYBER_Q;
    b = t;
    b >>s= 15;
    b &= KYBER_Q;
    t += b;
    rp[(int)i] = t;
    i += 1;
  }
  return rp;
}

fn _poly_basemul(reg ptr u16[KYBER_N] rp, reg const ptr u16[KYBER_N] ap bp) -> reg ptr u16[KYBER_N]
// requires {init_array(1,0,KYBER_N) && init_array(2,0,KYBER_N)}
// ensures {assigns_array(0,0,KYBER_N)}
{
  reg u64 offset;
  reg u16 zeta;
  reg u16 r0;
  reg u16 r1;
  reg u16 a0;
  reg u16 a1;
  reg u16 b0;
  reg u16 b1;
  reg u16 t;
  reg ptr u16[128] zetasp;
  reg u64 zetasctr;
  reg u64 i;

  stack ptr u16[KYBER_N] srp;

  srp = rp;

  zetasctr = 64;
  i = 0;

  while(i < KYBER_N)
  {
    zetasp = jzetas;
    zeta = zetasp[(int)zetasctr];
    zetasctr += 1;
    
    a0 = ap[(int)i];
    b0 = bp[(int)i];
    i += 1;
    a1 = ap[(int)i];
    b1 = bp[(int)i];
    i -= 1;

    r0 = __fqmul(a1, b1);
    r0 = __fqmul(r0, zeta);
    t  = __fqmul(a0, b0);
    r0 += t;

    r1 = __fqmul(a0, b1);
    t  = __fqmul(a1, b0);
    r1 += t;

    rp = srp;
    rp[(int)i]   = r0;
    i += 1;
    rp[(int)i] = r1;
    srp = rp;


    zeta = -zeta;

    i += 1;
    a0 = ap[(int)i];
    b0 = bp[(int)i];
    i += 1;
    a1 = ap[(int)i];
    b1 = bp[(int)i];
    i -= 1;

    r0 = __fqmul(a1, b1);
    r0 = __fqmul(r0, zeta);
    t  = __fqmul(a0, b0);
    r0 += t;

    r1 = __fqmul(a0, b1);
    t  = __fqmul(a1, b0);
    r1 += t;

    rp = srp;
    rp[(int)i]   = r0;
    i += 1;
    rp[(int)i] = r1;
    srp = rp;
    
    i += 1;
  }
  return rp;
}

inline
fn __poly_reduce(reg ptr u16[KYBER_N] rp) -> reg ptr u16[KYBER_N]
// requires {init_array(0,0,KYBER_N)}
// ensures {assigns_array(0,0,KYBER_N)}
{
  reg u64 j; 
  reg u16 t;
  j = 0;
  while (j < KYBER_N) 
  {
    t = rp[(int)j];
    t = __barrett_reduce(t);
    rp[(int)j] = t;
    j += 1;
  }
  return rp;
}

fn _poly_compress(reg u64 rp, reg ptr u16[KYBER_N] a) -> reg ptr u16[KYBER_N]
// requires {valid_memory(rp,0,128) && init_array(1,0,KYBER_N)}
// ensures {assigns_memory(rp,0,128) && assigns_array(0,0,KYBER_N)}
{
  reg u16 t;
  reg u32 d0, d1;
  reg u64 i j;

  a = _poly_csubq(a);

  i = 0;
  j = 0;
  while(i < 128)
  {
    t  = a[(int)j];
    d0 = (32u)t;
    d0 <<= 4;
    d0 += 1665;
    d0 *= 80635;
    d0 >>= 28;
    d0 &= 0xf;
    j += 1;
    t  = a[(int)j];
    d1 = (32u)t;
    d1 <<= 4;
    d1 += 1665;
    d1 *= 80635;
    d1 >>= 28;
    d1 &= 0xf;
    d1 <<= 4;
    d0 |= d1;
    (u8)[rp+i] = d0;
    i += 1;
    j += 1;
  }
  return a;
}

fn _i_poly_compress(reg ptr u8[KYBER_POLYCOMPRESSEDBYTES] rp, reg ptr u16[KYBER_N] a) -> reg ptr u8[KYBER_POLYCOMPRESSEDBYTES], reg ptr u16[KYBER_N]
// requires {init_array(1,0,KYBER_N)}
// ensures {assigns_array(0,0,128) && assigns_array(0,0,KYBER_N)}
{
  reg u16 t;
  reg u32 d0, d1;
  reg u64 i j;

  a = _poly_csubq(a);

  i = 0;
  j = 0;
  while(i < 128)
  {
    t  = a[(int)j];
    d0 = (32u)t;
    d0 <<= 4;
    d0 += 1665;
    d0 *= 80635;
    d0 >>= 28;
    d0 &= 0xf;
    j += 1;
    t  = a[(int)j];
    d1 = (32u)t;
    d1 <<= 4;
    d1 += 1665;
    d1 *= 80635;
    d1 >>= 28;
    d1 &= 0xf;
    d1 <<= 4;
    d0 |= d1;
    rp[(int) i] = d0;
    i += 1;
    j += 1;
  }
  return rp, a;
}


fn _poly_decompress(reg ptr u16[KYBER_N] rp, reg u64 ap) -> stack u16[KYBER_N]
// requires {valid_memory(ap,0,128) && init_memory(ap,0,128)}
// ensures {assigns_array(0,0,KYBER_N)}
{
  reg u8 t;
  reg u16 d0, d1;
  reg u64 i j;

  i = 0;
  j = 0;

  while (i < 128) {
    t  = (u8)[ap+i];
    d0 = (16u)t;
    d1 = (16u)t;
    d0 &= 0xf;
    d1 >>= 4;
    d0 *= KYBER_Q;
    d1 *= KYBER_Q;
    d0 += 8;
    d1 += 8;
    d0 >>= 4;
    d1 >>= 4;
    rp[(int)j] = d0;
    j += 1;
    rp[(int)j] = d1;
    j += 1;
    i += 1;
  }
  return rp;
}

fn _poly_frombytes(reg ptr u16[KYBER_N] rp, reg u64 ap) -> reg ptr u16[KYBER_N]
// requires {valid_memory(ap,0,384) && init_memory(ap,0,384)}
// ensures {assigns_array(0,0,KYBER_N)}
{
  reg u8 c0, c1, c2;
  reg u16 d0, d1, t;
  inline int i;

  for i = 0 to KYBER_N/2
  {
    c0 = (u8)[ap+3*i];
    c1 = (u8)[ap+3*i+1];
    c2 = (u8)[ap+3*i+2];
    d0 = (16u)c0;
    t  = (16u)c1;
    t &= 0xf;
    t <<= 8;
    d0 |= t;
    d1 = (16u)c2;
    d1 <<= 4;
    t  = (16u)c1;
    t >>= 4;
    d1 |= t;
    rp[2*i]   = d0;
    rp[2*i+1] = d1;
  }
  return rp;
}

param int DMONT   = 1353;      /* (1ULL << 32) % KYBER_Q */

fn _poly_frommont(reg ptr u16[KYBER_N] rp) -> reg ptr u16[KYBER_N]
// requires {init_array(0,0,KYBER_N)}
// ensures {assigns_array(0,0,KYBER_N)}
{
  reg u64 i;
  reg u16 r;
  reg u16 dmont;

  dmont = DMONT;
  
  i = 0;
  while (i < KYBER_N)
  {
    r = rp[(int)i];
    r = __fqmul(r, dmont);
    rp[(int)i] = r;
    i += 1;
  }
  return rp; 
}

fn _poly_frommsg(reg ptr u16[KYBER_N] rp, reg u64 ap) -> stack u16[KYBER_N]
// requires {init_memory(ap,0,32)}
// ensures {assigns_array(0,0,KYBER_N)}
{
  reg u8 c;
  reg u16 t;
  inline int i;
  inline int j;

  for i = 0 to 32
  {
    c = (u8)[ap + i];

    t = (16u)c; 
    t &= 1;
    t *= (KYBER_Q+1)/2;
    rp[8*i] = t;
    c >>= 1;

    t = (16u)c; 
    t &= 1;
    t *= (KYBER_Q+1)/2;
    rp[8*i+1] = t;
    c >>= 1;

    t = (16u)c; 
    t &= 1;
    t *= (KYBER_Q+1)/2;
    rp[8*i+2] = t;
    c >>= 1;

    t = (16u)c; 
    t &= 1;
    t *= (KYBER_Q+1)/2;
    rp[8*i+3] = t;
    c >>= 1;

    t = (16u)c; 
    t &= 1;
    t *= (KYBER_Q+1)/2;
    rp[8*i+4] = t;
    c >>= 1;

    t = (16u)c; 
    t &= 1;
    t *= (KYBER_Q+1)/2;
    rp[8*i+5] = t;
    c >>= 1;

    t = (16u)c; 
    t &= 1;
    t *= (KYBER_Q+1)/2;
    rp[8*i+6] = t;
    c >>= 1;

    t = (16u)c; 
    t &= 1;
    t *= (KYBER_Q+1)/2;
    rp[8*i+7] = t;
    c >>= 1;
  }
  return rp;
}


fn _i_poly_frommsg(reg ptr u16[KYBER_N] rp, reg ptr u8[32] ap) -> stack u16[KYBER_N]
// requires {init_array(0,0,32)}
// ensures {assigns_array(0,0,KYBER_N)}
{
  reg u8 c;
  reg u16 t;
  inline int i;
  inline int j;

  for i = 0 to 32
  {
    c = ap[i];

    t = (16u)c; 
    t &= 1;
    t *= (KYBER_Q+1)/2;
    rp[8*i] = t;
    c >>= 1;

    t = (16u)c; 
    t &= 1;
    t *= (KYBER_Q+1)/2;
    rp[8*i+1] = t;
    c >>= 1;

    t = (16u)c; 
    t &= 1;
    t *= (KYBER_Q+1)/2;
    rp[8*i+2] = t;
    c >>= 1;

    t = (16u)c; 
    t &= 1;
    t *= (KYBER_Q+1)/2;
    rp[8*i+3] = t;
    c >>= 1;

    t = (16u)c; 
    t &= 1;
    t *= (KYBER_Q+1)/2;
    rp[8*i+4] = t;
    c >>= 1;

    t = (16u)c; 
    t &= 1;
    t *= (KYBER_Q+1)/2;
    rp[8*i+5] = t;
    c >>= 1;

    t = (16u)c; 
    t &= 1;
    t *= (KYBER_Q+1)/2;
    rp[8*i+6] = t;
    c >>= 1;

    t = (16u)c; 
    t &= 1;
    t *= (KYBER_Q+1)/2;
    rp[8*i+7] = t;
    c >>= 1;
  }
  return rp;
}

/*
fn _poly_getnoise(reg ptr u16[KYBER_N] rp, reg ptr u8[KYBER_SYMBYTES] seed, reg u8 nonce) -> reg ptr u16[KYBER_N]
{
  stack u8[33] extseed;   /* 33 = KYBER_SYMBYTES +1 */
  stack u8[128] buf;      /* 128 = KYBER_ETA*KYBER_N/4 */
  reg u64 outlen;
  reg u8 c,a,b;
  reg u16 t;
  reg u64 i j;
  inline int k;

  stack ptr u16[KYBER_N] srp;

  srp = rp;
  
  for k = 0 to KYBER_SYMBYTES
  {
    c = seed[k];
    extseed[k] = c;
  }
  extseed[KYBER_SYMBYTES] = nonce;

  buf = _shake256_128_33(buf, extseed);

  rp = srp;

  i = 0;
  j = 0;
  while (i < 128) {
    c = buf[(int)i];
    a = c;
    a &= 0x55;

    c >>= 1;
    c &= 0x55;
    c += a;

    a = c;
    a &= 0x3;
    b = c;
    b >>= 2;
    b &= 0x3;
    a -= b;
    t = (16s)a;
    rp[(int)j] = t;
    a = c;
    a >>= 4;
    a &= 0x3;
    b = c >> 6;
    b &= 0x3;
    a -= b;
    t = (16s)a;
    j += 1;
    rp[(int)j] = t;
    i += 1;
    j += 1;
  }
  
  return rp;
}
*/

fn _poly_invntt(reg ptr u16[KYBER_N] rp) -> reg ptr u16[KYBER_N]
// requires {init_array(0,0,KYBER_N)}
// ensures {assigns_array(0,0,KYBER_N)}
{
  reg u64 len;  
  reg u64 start;
  reg u64 j;
  reg u64 cmp;
  reg u64 offset;
  
  reg u16 zeta;
  reg u16 t;
  reg u16 s;
  reg u16 m;

  reg ptr u16[128] zetasp;
  reg u64 zetasctr;

  zetasp = jzetas_inv;
  zetasctr = 0;

  len = 2;
  while (len <= 128)
  {
    start = 0;
    while (start < 256)
    {
      zeta = zetasp[(int)zetasctr];
      zetasctr += 1;

      j = start;
      cmp = start + len;
      while (j < cmp)
      {
        offset = j + len;
        s = rp[(int)offset];
        t = rp[(int)j];
        m = s + t;
        m = __barrett_reduce(m);
        rp[(int)j] = m;
        t -= s;
        t = __fqmul(t, zeta);
        rp[(int)offset] = t;
        j += 1;
      }
      start = j + len;
    }
    len <<= 1;
  }

  zeta = zetasp[127];
  j = 0;
  while (j < KYBER_N) 
  {
    t = rp[(int)j];
    t = __fqmul(t, zeta);
    rp[(int)j] = t;
    j += 1;
  }
  return rp;
}

fn _poly_ntt(reg ptr u16[KYBER_N] rp) -> reg ptr u16[KYBER_N]
// requires {init_array(0,0,KYBER_N)}
// ensures {assigns_array(0,0,KYBER_N)}
{
  reg u64 len;  
  reg u64 start;
  reg u64 j;
  reg u64 cmp;
  reg u64 offset;
  
  reg u16 zeta;
  reg u16 t;
  reg u16 s;
  reg u16 m;

  reg ptr u16[128] zetasp;
  reg u64 zetasctr;

  zetasp = jzetas;
  zetasctr = 0;
  len = 128;
  while (len >= 2)
  {
    start = 0;
    while (start < 256)
    {
      zetasctr += 1;
      zeta = zetasp[(int)zetasctr];
      j = start;
      cmp = start + len;
      while (j < cmp)
      {
        offset = j + len;
        t = rp[(int)offset];
        t = __fqmul(t, zeta);
        s = rp[(int)j];
        m = s;
        m -= t;
        rp[(int)offset] = m;
        t += s;
        rp[(int)j] = t;
        j += 1;
      }
      start = j + len;
    }
    len >>= 1;
  }

  rp = __poly_reduce(rp);

  return rp;
}

fn _poly_sub(reg ptr u16[KYBER_N] rp ap bp) -> reg ptr u16[KYBER_N]
// requires {init_array(0,0,KYBER_N) && init_array(1,0,KYBER_N)}
// ensures {assigns_array(0,0,KYBER_N)}
{
  reg u16 a;
  reg u16 b;
  reg u16 r;
  reg u64 i;

  i = 0;
  while (i < KYBER_N) {
    a = ap[(int)i];
    b = bp[(int)i];
    r = a - b;
    rp[(int)i] = r;
    i += 1;
  }
  return rp;
}

fn _poly_tobytes(reg u64 rp, reg ptr u16[KYBER_N] a) -> reg ptr u16[KYBER_N]
// requires {valid_memory(rp,0,384) && init_array(1,0,KYBER_N)}
// ensures {assigns_array(0,0,KYBER_N) &&  assigns_memory(rp,0,384)}
{
  reg u16 t0, t1, d;
  reg u64 i j;

  a = _poly_csubq(a);

  i = 0;
  j = 0;
  while (i < KYBER_N)
  {
    t0 = a[(int)i]; 
    i += 1;
    t1 = a[(int)i]; 
    i += 1;
    d  = t0;
    d  &= 0xff;
    (u8)[rp+j] = d;
    j += 1;
    t0 >>= 8;
    d = t1;
    d &= 0xf;
    d <<= 4;
    d |= t0;
    (u8)[rp+j] = d;
    j += 1;
    t1 >>= 4;
    (u8)[rp+j] = t1;
    j += 1;
  }
  return a;
}

fn _poly_tomsg(reg u64 rp, reg ptr u16[KYBER_N] a) -> reg ptr u16[KYBER_N]
// requires {valid_memory(rp,0,32) && init_array(1,0,KYBER_N)}
// ensures {assigns_array(0,0,KYBER_N) &&  assigns_memory(rp,0,32)}
{
  reg u16 t;
  reg u8 r;
  reg u32 d;
  inline int i j;

  a = _poly_csubq(a); 

  for i = 0 to 32
  {
    r = 0;
    for j = 0 to 8
    {
      t = a[8*i+j]; 
      d = (32u)t; 
      d <<= 1;
      d += 1665;
      d *= 80635;
      d >>= 28;
      d &= 1;
      d <<= j;
      r  |= d;
    }

    (u8)[rp+i] = r;
  }
  return a;
}

fn _i_poly_tomsg(reg ptr u8[KYBER_N/8] rp, reg ptr u16[KYBER_N] a) -> reg ptr u8[KYBER_N/8], reg ptr u16[KYBER_N]
// requires {init_array(1,0,KYBER_N)}
// ensures {assigns_array(0,0,KYBER_N) &&  assigns_array(1,0,32)}
{
  reg u16 t;
  reg u8 r;
  reg u32 d;
  inline int i j;

  a = _poly_csubq(a); 

  for i = 0 to 32
  {
    r = 0;
    for j = 0 to 8
    {
      t = a[8*i+j]; 
      d = (32u)t; 
      d <<= 1;
      d += 1665;
      d *= 80635;
      d >>= 28;
      d &= 1;
      d <<= j;
      r  |= d;
    }

    rp[i] = r;
  }

  return rp, a;
}
